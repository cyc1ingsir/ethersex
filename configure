#! /usr/bin/perl -w
# Copyright (c) 2007, 2008 by Stefan Siegl <stesie@brokenpipe.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# For more information on the GPL, please go to:
# http://www.gnu.org/copyleft/gpl.html

use strict;
use Term::Prompt;

my %ethersex_modules = (
  'ecmd'      => { 
                   helptext  => "telnet-based etherrape control interface",
                   conflicts => [ "bootloader" ],
                   distdflt  => 1,
		   enable_hook => \&ecmd_enable_hook,
                 },
  'portio'    => {
                   helptext  => "port io abstraction layer",
                   distdflt  => 1,
                   conflicts => [ "portio_simple" ],
                 },
  'portio_simple'    => {
                   helptext  => "port io abstraction layer simplified version",
                   distdflt  => 1,
                   conflicts => [ "portio" ],
                 },
  'named_pin'  => {
                   helptext => "pins with names and logic states",
                   requires  => [ "portio" ],
                   distdflt => 0,
                 },
  'ecmd_sender'  => {
                   helptext => "send an ecmd to another host",
                   distdflt => 0,
                 },
  'watchcat'  => {
                   helptext => "watch io changes and react",
                   requires => ["ecmd_sender", "portio"],
                   distdflt => 0,
                 },
  'fs20'      => { 
                   helptext  => "fs20 rf-control interface",
                   distdflt  => 0,
                   conflicts => [ "bootloader" ],
                 },
  'bootp'     => { 
                   helptext  => "DHCP-like autoconfig for IPv4",
                   conflicts => [ "ipv6", "tftpomatic" ],
		   # require handled in enable-hook since we don't need to 
		   # do require here, if openvpn is enabled.
                   maybe_require  => [ "broadcast", "udp" ],
                   preconfigure => [ "ipv6" ],
                   distdflt  => 0,
		   enable_hook => \&bootp_enable_hook
                 },
  'bootp_to_eeprom' => {
                   helptext  => "store BOOTP-aquired data to EEPROM",
		   requires  => [ "bootp", "bootloader" ],
		   preconfigure => [ "bootp" ],
		   distdflt  => 0,
		 },
  'ipv6'      => { 
                   helptext  => "IPv6 support instead of IPv4",
                   conflicts => [ "bootp", "broadcast" ],
                   preconfigure => [ "enc28j60" ],
		   requires => [ "icmp" ],
                   distdflt  => 1,
                   enable_hook  => \&ipv6_enable_hook,
                   disable_hook  => \&ipv6_disable_hook,
                 },
  'ipv6_static'      => { 
                   helptext  => "static IPv6 address",
                   preconfigure => [ "ipv6" ],
                   requires => [ "ipv6" ],
                   distdflt  => 0,
                 },
  'broadcast' => { 
                   helptext  => "broadcast support",
                   requires  => [ "udp" ],
		   conflicts => [ "ipv6" ],
                   distdflt  => 0,
                 },
  'icmp'      => { 
                   helptext  => "icmp support",
                   distdflt  => 1,
                 },
  'udp'       => { 
                   helptext  => "udp support",
                   distdflt  => 1,
                 },
  'tcp'       => { 
                   helptext  => "tcp support",
                   distdflt  => 1,
                 },
  'rfm12_linkbeat_net' => {
                   helptext  => "send linkbeat packets on rfm12 link regularly (testing only)",
                   requires  => [ "rfm12" ],
                   distdflt  => 0,
                 },
  'zbus_linkbeat_net' => {
                   helptext  => "send linkbeat packets on rfm12 link regularly (testing only)",
		   requires  => [ "zbus" ],
                   distdflt  => 0,
                 },
  'udp_echo_net' => {
                   helptext  => "udp-bound echo application",
                   distdflt  => 0,
                 },
  'tftpomatic'=> {
                   helptext  => "automatic firmware loading using tftp",
                   requires  => [ "tftp" ],
                   conflicts => [ "bootp" ],
                   preconfigure => [ "bootp" ],
                   enable_hook  => \&tftpomatic_enable_hook,
                   distdflt  => 0,
                 },
  'tftp'      => { 
                   helptext  => "TFTP-based firmware bootloader",
                   requires  => [ "bootloader", "udp" ],
                   preconfigure => [ "tftpomatic", "skipjack" ],
                   enable_hook  => \&tftp_enable_hook,
                   distdflt  => 0,
                 },
  'hd44780'   => {
                   helptext  => "Character-LCD module driver",
                   distdflt  => 0,
                 },
  'bootloader'=> {
                   helptext  => "configure as bootloader",
		   requires  => [ "teensy" ],
                   distdflt  => 0,
                 },
  'skipjack'  => {
                   helptext  => "skipjack block cipher",
                   requires  => [ "crypto" ],
                   conflicts => [ "cast5" ],
                   distdflt  => 0,
                 },
  'cast5'     => {
                   helptext  => "cast5 block cipher",
                   requires  => [ "crypto" ],
                   conflicts => [ "skipjack", "bootloader" ],
                   distdflt  => 0,
                 },
  'md5'       => {
                   helptext  => "md5 hash support",
                   requires  => [ "crypto" ],
                   distdflt  => 0,
                 },
  'crypto'    => {
                   helptext  => "generic crypto support",
                   distdflt  => 0,
                   virtual   => 1,
                 },
  'openvpn'   => {
                   helptext  => "openvpn support",
		   distdflt  => 0,
		   preconfigure => [ "cast5", "md5" ],
		   enable_hook => \&openvpn_enable_hook,
                 },
  'stella'    => {
                   helptext  => "stella light support",
		   distdflt  => 0,
		   preconfigure => [ "udp" ],
                 },
  'teensy'    => {
                   helptext  => "try to keep flash memory needs minimal",
		   distdflt  => 0,
                 },
  'onewire'   => {
                   helptext  => "onewire device support",
                   distdflt  => 0,
                 },
  'rc5'       => {
                   helptext  => "sending rc5 IR codes",
                   distdflt  => 0,
		   conflicts => [ "rfm12" ],
                 },
  'rfm12'     => {
                   helptext  => "rfm12 fsk transmitter",
                   distdflt  => 0,
		   conflicts => [ "rc5" ],
		   enable_hook => \&rfm12_enable_hook,
		   preconfigure => [ "skipjack", "enc28j60" ],
                 },
  'rfm12_raw' => {
                   heptext   => "rfm12 udp tunnel",
		   distdflt  => 0,
		   requires  => [ "rfm12", "enc28j60" ],
                 },
  'rfm12_beacon' => {
                   helptext  => "enable rfm12 beacon-feature",
		   distdflt  => 0,
		   requires  => [ "rfm12" ],
		   conflicts => [ "rfm12_cloud" ],
		   enable_hook => \&rfm12_beacon_enable_hook,
		 },
  'rfm12_cloud' => {
                   helptext  => "rfm12 network clouds (EXPERIMENTAL)",
                   distdflt  => 0,
                   requires => [ "rfm12", "udp_dns_mcast" ],
                   enable_hook => \&rfm12_cloud_enable_hook,
		   conflicts => [ "rfm12_beacon" ],
                 },
  'dns'       => {
                   helptext  => "dns name resolver",
                   distdflt  => 0,
                   requires => ["udp"],
                   preconfigure => [ "bootp" ],
                   enable_hook  => \&dns_enable_hook,
                 },
  'udp_dns_mcast'   => {
                   helptext  => "dns-based udp multicaster",
                   distdflt  => 0,
                   requires  => [ "dns" ],
                 },
  'adc'       => {
                   helptext  => "get adc values",
                   distdflt  => 0,
                   requires => ["ecmd"],
                 },
  'dyndns'        => {
                   helptext  => "updating an dns name on dyn.metafnord.de",
                   distdflt  => 0,
                   enable_hook  => \&dyndns_enable_hook,
                 },
  'syslog'        => {
                   helptext  => "sending syslog messages",
                   distdflt  => 0,
                   requires => ["udp"],
                   enable_hook  => \&syslog_enable_hook,
                 },
  'i2c'        => {
                   helptext  => "i2c to udp gateway",
                   distdflt  => 0,
                   conflicts => [ "i2c_slave" ],
                   requires => ["udp"],
                 },
  'i2c_slave'  => {
                   helptext  => "i2c slave to udp gateway",
                   distdflt  => 0,
                   conflicts => [ "i2c" ],
                   requires => ["udp"],
                   enable_hook  => \&i2c_slave_enable_hook,
                 },
  'clock'        => {
                   helptext  => "system clock",
                   distdflt  => 0,
                   enable_hook  => \&clock_enable_hook,
  },
  'clock_crystal'        => {
                   helptext  => "use crystal (32kHz) to tick system clock",
                   distdflt  => 0,
                   preconfigure => [ "clock" ],
                   requires => ["clock"],
                   conflicts => [ "stella" ],
                 },
  'dcf77'        => {
                   helptext  => "synchronize the clock with the dcf77 signal
                     (experimental)",
                   distdflt  => 0,
                   preconfigure => [ "clock" ],
                   requires => ["clock", "clock_crystal"],
                 },
  'ntp'        => {
                   helptext  => "get time via ntp protocol",
                   distdflt  => 0,
                   preconfigure => [ "clock" ],
                   requires => ["clock", "udp"],
                 },
  'ntpd'        => {
                   helptext  => "provide the system clock via ntp",
                   distdflt  => 0,
                   requires => ["clock", "udp"],
  },
  'mdns_sd'        => {
                   helptext  => "mdns service announcement",
                   distdflt  => 0,
                   requires => ["udp"],
		   enable_hook => \&mdns_enable_hook,
  },
  'enc28j60'  => {
                   helptext  => "enc28j60 ethernet controller",
                   distdflt  => 1,
		   enable_hook => \&enc28j60_enable_hook,
		   disable_hook => \&enc28j60_disable_hook,
                 },
  'ps2'        => {
                   helptext  => "ps2 keyboard",
                   distdflt  => 0,
                 },
  'hc595'        => {
                   helptext  => "use an hc595 as output expansion",
                   distdflt  => 0,
                 },
  'hc165'        => {
                   helptext  => "use an hc165 as input expansion",
                   distdflt  => 0,
                 },
# All modules with usart use
  'usart'        => {
                   helptext  => "generic usart support",
                   distdflt  => 0,
                   virtual   => 1,
                 },
  'yport'        => {
                   helptext  => "an serial to ip converter",
                   distdflt  => 0,
                   conflicts => [ "zbus", "modbus" ],
                   requires  => [ "usart" ],
                 },
  'modbus'        => {
                   helptext  => "an modbus-tcp bridge",
                   distdflt  => 0,
                   conflicts => [ "zbus", "yport" ],
                   requires  => [ "usart" ],
                 },
  'zbus'        => {
                   helptext  => "tunneling ip over zbus",
                   distdflt  => 0,
                   enable_hook => \&zbus_enable_hook,
                   conflicts => [ "modbus", "yport" ],
                   requires => [ "usart" ],
		   preconfigure => [ "skipjack", "enc28j60" ],
                 },
  'zbus_raw' => {
                   heptext   => "zbus udp tunnel",
		   distdflt  => 0,
		   requires  => [ "zbus", "enc28j60" ],
                 },
);
my %categories = (
  'applications' => {
                   helptext  => "applications",
		   modules   => [ 
		                  "clock", "clock_crystal",
		                  "dcf77",
		                  "dyndns", 
		                  "ecmd", "ecmd_sender", 
		                  "hd44780", 
		                  "ntp", "ntpd",
		                  "mdns_sd",
		                  "stella", 
		                  "watchcat", 
		                ],
                 },
  'connectors'  => {
                   helptext  => "contectors",
                   modules   => [ "yport", 
                                  "i2c", "i2c_slave",
		                  "fs20", 
		                  "rc5", 
		                  "modbus", "usart",
		                ],
		 },
  'bootloading' => {
                   helptext  => "bootloading",
                   modules   => [ "bootp", "tftp", "tftpomatic", "bootloader", "bootp_to_eeprom" ],
                 },
  'protocols' => {
		   helptext  => "network protocols",
		   modules   => [ "dns", "syslog", "tcp", "udp", "udp_dns_mcast",
				  "icmp", "ipv6", "ipv6_static", "zbus_raw", 
				  "rfm12_raw"],
                 },
  'interfaces'   => {
		   helptext  => "network interfaces",
		   modules   => [ "enc28j60", "zbus", "rfm12", "rfm12_cloud" ],
                 },
  'io'		 => {
		   helptext  => "i/o support",
		   modules   => [ "portio", "portio_simple", "hc595", "hc165", "ps2", "adc", "onewire", "named_pin" ],
		 },
  'crypto'       => {
                   helptext  => "cryptographic functionality",
                   modules   => [ "skipjack", "cast5", "md5", "crypto", 'openvpn' ],
                 },
  'options'      => {
                   helptext  => "configuration options",
                   modules   => [ "teensy", "broadcast" ],
                 },
  'debug'        => {
                   helptext  => "debugging stuff",
                   modules   => [ "udp_echo_net", "zbus_linkbeat_net", "rfm12_linkbeat_net" ],
                 },
);

# the define filter is used in the -D ARGV handling:
# it checks the specified value and expand it to a config.h compatible mode
# e.g. 192.168.1.1 -> uip_ipaddr(ip,192,168,1,1)

my %ethersex_config = (
  'hostname' => {
                   helptext  => "hostname of the device",
                   definefilter => \&check_and_expand_string,
                 },
  'etherrape_ip' => {
                   helptext  => "default ip address (inner part, if OpenVPN)",
                   definefilter => \&check_and_expand_ip,
                 },
  'etherrape_ip6_prefix_len' => {
                   helptext  => "ipv6 prefix len (IPv6 only)",
                   definefilter => \&check_and_expand_numeric,
                 },
  'etherrape_ip4_netmask'   => {
                   helptext  => "default netmask (IPv4 only)",
                   definefilter => \&check_and_expand_ipv4,
                 },
  'etherrape_ip4_gateway'   => {
                   helptext  => "default gateway (IPv4 only)",
                   definefilter => \&check_and_expand_ipv4,
                 },
  'etherrape_mac'   => {
                   helptext  => "mac address of the etherrape",
                   definefilter => \&check_and_expand_mac,
                 },
  'bootload_delay' => {
                   helptext  => "time until the bootloader starts the app",
                   definefilter => \&check_and_expand_numeric,
                 },
  'zbus_ip' => {
                   helptext  => "zbus stack ip address",
                   definefilter => \&check_and_expand_ip,
                 },
  'zbus_ip4_netmask' => {
                   helptext  => "zbus stack netmask (IPv4 only)",
                   definefilter => \&check_and_expand_ipv4,
                 },
  'zbus_ip6_prefix_len' => {
                   helptext  => "zbus stack prefix length (IPv6 only)",
                   definefilter => \&check_and_expand_numeric,
                 },
  'zbus_key'   =>{
                   helptext  => "hex-encoded zbus encryption key",
                   definefilter => \&check_and_expand_cryptokey,
                 },
  'rfm12_ip' => {
                   helptext  => "rfm12 stack ip address",
                   definefilter => \&check_and_expand_ip,
                 },
  'rfm12_ip4_netmask' => {
                   helptext  => "rfm12 stack netmask (IPv4 only)",
                   definefilter => \&check_and_expand_ipv4,
                 },
  'rfm12_ip6_prefix_len' => {
                   helptext  => "rfm12 stack prefix length (IPv6 only)",
                   definefilter => \&check_and_expand_numeric,
                 },
  'rfm12_key'   =>{
                   helptext  => "hex-encoded rfm12 encryption key",
                   definefilter => \&check_and_expand_cryptokey,
                 },
  'rfm12_beacon_id' => {
                   helptext  => "the unique ID byte assigned to the rfm12 beacon",
                   definefilter => \&check_and_expand_numeric,
                 },
  'rfm12_cloud_dns' => {
		   helptext  => "dns (host)name of the rfm12 cloud",
                   definefilter => \&check_and_expand_string,
                 },
  'i2c_slave_addr'   =>{
                   helptext  => "hex-encoded i2c slave address",
                 },
  'openvpn_ip4'   => {
                   helptext  => "ip address of the openvpn gateway",
                   definefilter => \&check_and_expand_ipv4,
                 },
  'openvpn_ip4_netmask'   => {
                   helptext  => "netmask for openvpn gateway",
                   definefilter => \&check_and_expand_ipv4,
                 },
  'openvpn_ip4_gateway'   => {
                   helptext  => "default gateway for openvpn gateway",
                   definefilter => \&check_and_expand_ipv4,
                 },
  'openvpn_key'   =>{
                   helptext  => "hex-encoded openvpn encryption key",
                   definefilter => sub { $a = shift;
                     return check_and_expand_cryptokey ($a, 16);
                   },
                 },
  'openvpn_hmac_key'   =>{
                   helptext  => "hex-encoded openvpn hmac auth key",
                   definefilter => sub { $a = shift;
                     return check_and_expand_cryptokey ($a, 16);
                   },
                 },
  'tftp_ip'   => {
                   helptext  => "ip address of tftp server",
                   definefilter => \&check_and_expand_ip,
                 },
  'tftp_image' =>{
                   helptext  => "name of tftp image to download",
                   definefilter => \&check_and_expand_string,
                 },
  'tftp_key'   =>{
                   helptext  => "hex-encoded skipjack key for tftp",
                   definefilter => \&check_and_expand_cryptokey,
                 },
  'dns_server' =>{
                   helptext  => "ip address of the default dns server",
                   definefilter => \&check_and_expand_ip,
                 },
  'dyndns_hostname' => {
                   helptext  => "hostname to be updated via dyndns",
                   definefilter => \&check_and_expand_string,
                },
  'dyndns_username' => {
                   helptext  => "hostname to be updated via dyndns",
                   definefilter => \&check_and_expand_string,
                },
  'dyndns_password' => {
                   helptext  => "hostname to be updated via dyndns",
                   definefilter => \&check_and_expand_string,
                },
  'syslog_server' => {
                   helptext  => "ip address of the syslog server",
                   definefilter => \&check_and_expand_ip,
                },
);


#
# check for modules with unassigned categories
#
foreach my $cat (keys %categories) {
  foreach (@{$categories{$cat}->{modules}}) {
    $ethersex_modules{$_}->{"category"} = $_;
  }
}
foreach(keys %ethersex_modules) {
  warn "module '$_' has no assigned category" 
    unless defined $ethersex_modules{$_}->{"category"};
}

my $opt_restore_defaults = 0;
my $opt_only_modules = 0;
my $opt_tk_gui = 0;
my $opt_nogui = 0;
foreach(@ARGV) {
  if(m/^--restore-defaults$/) { $opt_restore_defaults = 1; $opt_nogui = 1; }
  if(m/^--only-modules$/) { $opt_only_modules = 1; }
  if(m/^--tk$/) { $opt_tk_gui = 1; $opt_nogui = 1; }
  if(m/^--help$/ or m/^-h$/) { 
    print STDERR "ethersex configuration utility\n";
    print STDERR "  --restore-defaults  - enable only default modules\n";
    print STDERR "  --only-modules      - configure only the modules\n";
    print STDERR "  --tk-gui            - use Perl/TK GUI\n";
    print STDERR "  --disable-x         - disable feature 'x'\n";
    print STDERR "  --enable-x          - enable feature 'x'\n";
    print STDERR "  --D<option>=<value> - set option to value\n";
    exit 0;
  }
}

#
# scan `config.h' for enabled/disabled modules
#
open HANDLE, "< config.h"
  or die "unable to read config.h file";
while(<HANDLE>) {
  chop $_;
  if(my ($enabled, $modname) = 
     m/^(\/*|\/\/)?\s*#define\s+([A-Z0-9_]+)_SUPPORT\s*(?:\*\/)?\s*$/) {

    unless(defined($ethersex_modules{lc($modname)})) {
      warn "unknown ethersex module '" . lc($modname) . "' listed in config.h";
      next;
    }

    $ethersex_modules{lc($modname)}->{'enabled'} = !length($enabled);
  }
  if(my ($confopt, $confvalue) =
     m/#define\s+CONF_([A-Z0-9_]+)\s+(.*)$/) {

    unless(defined($ethersex_config{lc($confopt)})) {
      warn "unknown ethersex config '" . lc($confopt) . "' listed in config.h";
      next;
    }

    $ethersex_config{lc($confopt)}->{'value'} = $confvalue;
  }
}
close HANDLE or die;

foreach(@ARGV) {
  if(m/--enable-([A-Z0-9_]+)/i) {
    if(defined($ethersex_modules{lc $1})
       && !defined($ethersex_modules{lc $1}->{'new_status'})
       && try_enable(lc $1) == 0) {
      $opt_nogui = 1;
      printf "enabling %s.\n", lc $1
        unless($ethersex_modules{lc $1}->{'enabled'});
      enable(lc $1);
    }
    else {
      print "FAILED to enable $1.\n";
    }
  }

  if(m/--disable-([A-Z0-9_]+)/i) {
    if(defined($ethersex_modules{lc $1})
       && !defined($ethersex_modules{lc $1}->{'new_status'})) {
      $opt_nogui = 1;
      printf "disabling %s.\n", lc $1
        if($ethersex_modules{lc $1}->{'enabled'});
      disable(lc $1);
    }
    else {
      print "FAILED to disable $1.\n";
    }
  }
}

# the defines options must be configured after the enable/disable options
foreach(@ARGV) {
  if(m/^-D([^=]*)=(.*$)/) { 
    if (defined($ethersex_config{$1})) {
        my $uservalue = $2;
        $opt_nogui = 1;
        if (defined($ethersex_config{$1}->{'definefilter'})) {
          $uservalue = $ethersex_config{$1}->{'definefilter'}($uservalue);
        }
        if (!defined($uservalue) || $uservalue eq "") {
          print STDERR "Invalid define option: $1\n";
          exit -1;
        }
        $ethersex_config{$1}->{'user_value'} = $2;
        print "setting $1 to $2.\n";
    } else {
      print STDERR "Unkown define option: $1\n";
      exit -1;
    }
  }
}

if ($opt_nogui) {
  foreach (keys(%ethersex_modules)) {
    if (!defined $ethersex_modules{$_}->{'new_status'}) {
      $ethersex_modules{$_}->{'new_status'} = $ethersex_modules{$_}->{'enabled'};
    }
  }
}

# return a list of enabled modules
sub enable_modules() {
  my @list;
  foreach my $m (keys %ethersex_modules) {
    next unless defined $ethersex_modules{$m}->{'new_status'};
    push @list, $m if $ethersex_modules{$m}->{'new_status'};
  }
  return @list;
}

# return a list of enabled modules
sub disable_modules() {
  my @list;
  foreach my $m (keys %ethersex_modules) {
    next unless defined $ethersex_modules{$m}->{'new_status'};
    push @list, $m unless $ethersex_modules{$m}->{'new_status'};
  }
  return @list;
}

# check whether module may be enabled
# return: 1 if conflicting (message will be emitted)
sub try_enable {
  my $module = shift;
  my $trymodule = shift;

  unless(defined($trymodule)) { $trymodule = $module }

  foreach my $module_conflicts (@{$ethersex_modules{$module}->{'conflicts'}}) {
    foreach (enable_modules()) {
      if($_ eq $module_conflicts) {
        disable($trymodule, $_);

        return 1;
      }
    }
  }

  foreach (@{$ethersex_modules{$module}->{'requires'}},
           @{$ethersex_modules{$module}->{'maybe_require'}}) {
    if(defined($ethersex_modules{$_}->{'new_status'})
       && !$ethersex_modules{$_}->{'new_status'}) {
      # module is already disabled ....
      printf "disabling %s (would require %s).\n", $trymodule, $_
        unless($opt_nogui);
      disable($trymodule);

      return 1;
    }
    if(try_enable($_, $trymodule)) {
      return 1;
    }
  }

  return 0;
}

sub enable {
  my $module = shift;
  my $requiring = shift;

  #if($ethersex_modules{$module}->{'new_status'});

  if(defined($requiring)) {
    if(defined($ethersex_modules{$module}->{'new_status'})
       ? !$ethersex_modules{$module}->{'new_status'}
       : !$ethersex_modules{$module}->{'enabled'}) {
      printf "enabling %s (required by %s).\n", $module, $requiring;
    }
  } else {
    $requiring = $module;
  }

  foreach (@{$ethersex_modules{$module}->{'requires'}}) {
    enable($_, $requiring);
  }

  $ethersex_modules{$module}->{'new_status'} = 1;

  # call hook, if available
  if(defined($ethersex_modules{$module}->{'enable_hook'})) {
    $ethersex_modules{$module}->{'enable_hook'}();
  }
}

sub disable {
  my $module = shift;
  my $conflicting = shift;

  if(defined($conflicting)
     && (defined($ethersex_modules{$module}->{'new_status'})
         ? $ethersex_modules{$module}->{'new_status'}
         : $ethersex_modules{$module}->{'enabled'})) {
    printf "disabling %s (conflicting with %s).\n", $module, $conflicting;
  } 

  $ethersex_modules{$module}->{'new_status'} = 0;

  # disable modules, that have been enabled before and that require this one ...
  foreach my $testmod (keys %ethersex_modules) {
    next unless defined $ethersex_modules{$testmod}->{"new_status"};
    next unless $ethersex_modules{$testmod}->{"new_status"};

    foreach my $reqmod (@{$ethersex_modules{$testmod}->{'requires'}}) {
      if($reqmod eq $module) { 
        &disable ($testmod, $module); 
      }
    }
  }

  # call hook, if available
  if(defined($ethersex_modules{$module}->{'disable_hook'})) {
    $ethersex_modules{$module}->{'disable_hook'}();
  }
}


# configure module (return 1, if config has been changed, 0 otherwise)
sub configure_module {
  my ($module) = @_;

 restart:
  # check whether we've already asked the user (or implied an answer)
  return(0) if(defined($ethersex_modules{$module}->{'new_status'}));

  return(0) if(try_enable($module));  # cannot enable, conflicting.

  # perform forced preconfiguration ...
  if(defined($ethersex_modules{$module}->{'preconfigure'})) {
    foreach (@{$ethersex_modules{$module}->{'preconfigure'}}) {
      if(configure_module($_)) { goto restart; }
    }
  }

  # automatic handling of virtual modules ...
  if($ethersex_modules{$module}->{'virtual'}) {
    # configure all modules depending on this module
    foreach (keys %ethersex_modules) { 
      next if $_ eq $module;
      next unless defined $ethersex_modules{$_}->{'requires'};
      foreach my $dependency (@{$ethersex_modules{$_}->{'requires'}}) {
        if($dependency eq $module) {
          if(configure_module($_)) { goto restart; }
        }
      }
    }
    
    print "disabling unneeded, virtual module $module.\n";
    disable $module;
    return 1;
  }

  my $answer;
  if($opt_restore_defaults) { 
    $answer = $ethersex_modules{$module}->{'distdflt'};
    printf "%s %s.\n", ($answer ? "enabling" : "disabling"), $module
      unless($ethersex_modules{$module}->{'enabled'} 
             == $ethersex_modules{$module}->{'distdflt'});
  }
  elsif($opt_nogui && defined($ethersex_modules{$module}->{'enabled'})) {
    $answer = $ethersex_modules{$module}->{'enabled'};
    #printf "%s %s.\n", ($answer ? "enabling" : "disabling"), $module
    #  unless($opt_tk_gui);
  }
  else {
    $answer = prompt('y', sprintf("enable %s?", $module),
                     $ethersex_modules{$module}->{'helptext'}, 
                     $ethersex_modules{$module}->{'enabled'});
  }

  if($answer) {
    enable($module);
  } 
  else {
    disable($module);
  }

  return 1;
}

sub ipv6_expand {
  my $ip = shift;
  my @colons = $ip =~ m/:/g;
  if(scalar(@colons) > 7) { return undef; }
  unless($ip =~ m/::/) { return $ip }

  my $replacement = ":0" x (8 - scalar(@colons)) . ":";
  $ip =~ s/::/$replacement/;
  if($ip =~ m/^:/) { $ip = "0$ip"; }
  if($ip =~ m/:$/) { $ip .= "0"; }

  return $ip;
}

# return 1 if provided IP address is valid
sub check_ip {
  my $checkval = shift;
  unless($ethersex_modules{'ipv6'}->{'new_status'}) {
    # validate ipv4 addr
    my @parts = split m/\./, $checkval;
    if(scalar(@parts) != 4) { return 0; }
    foreach(@parts) {
      if($_ < 0 || $_ > 255) { return 0; }
    }
    return 1;
  }

  # validate ipv6 addr
  if($checkval =~ m/:::/) { return 1; }
  $checkval = ipv6_expand($checkval);
  if($checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){7}$/i) { return 1; }
  return 0;
}

sub ask_ip {
  return if($opt_nogui); # defer processing ...

  my $confopt = shift;
  my $new_value;

  configure_module "ipv6";
  if (defined($ethersex_config{$confopt}->{'user_value'})) {
    $new_value = $ethersex_config{$confopt}->{'user_value'};
    goto save_value;
  }

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }
  for($default) { s/0x//g; s/\s//g; s/^uip_ip6?addr\(ip,//; s/\)$//; }
  my $separator = $ethersex_modules{'ipv6'}->{'new_status'} ? ":" : ".";
  $default = join($separator, split(m/,/, $default));
  unless (check_ip($default)) { $default = "" }

  $new_value = 
    prompt('s', $confopt . "?", $ethersex_config{$confopt}->{'helptext'}, 
           $default, \&check_ip);

save_value:
  if($ethersex_modules{'ipv6'}->{'new_status'} && $new_value =~ m/::/) {
    $new_value = ipv6_expand($new_value);
  }

  my @parts = split(m/[\.:]/, $new_value);
  if($ethersex_modules{'ipv6'}->{'new_status'}) {
    foreach(@parts) { $_ = "0x" . $_ }
  }
  $ethersex_config{$confopt}->{'value'} = "uip_" .
    ($ethersex_modules{'ipv6'}->{'new_status'} ? "ip6addr" : "ipaddr") . "(ip,"
    . join(",", @parts) . ")"; 
}

sub check_mac {
  my $checkval = shift;
  if ($checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){5}$/i) { return 1;}
  return 0;
}

sub ask_mac {
  return if($opt_nogui); # defer processing ...

  my $confopt = shift;
  my $new_value;

  if($opt_restore_defaults) {
    $ethersex_config{$confopt}->{'value'} = '"\xAC\xDE\x48\xFD\x0F\xD0"';
    return;
  }

  if (defined($ethersex_config{$confopt}->{'user_value'})) {
    $new_value = $ethersex_config{$confopt}->{'user_value'};
    goto save_value;
  }

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  for($default) { s/"//g; s/\\x/:/g; s/^:// };
  $new_value =
    prompt('s', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, \&check_mac);
save_value:
  for($new_value) {s/:/\\x/g }
  
  $ethersex_config{$confopt}->{'value'} = '"\\x' . $new_value . '"';
}

sub ask_anything {
  return if($opt_nogui); # defer processing ...

  my $confopt = shift;
  my $new_value;

  if (defined($ethersex_config{$confopt}->{'user_value'})) {
    $new_value = $ethersex_config{$confopt}->{'user_value'};
  } else {
    my $d = $ethersex_config{$confopt}->{'value'};
    unless(defined($d)) { $d = ""; }
    for($d) { s/^"//; s/"$//; }

    $new_value =
      prompt('x', $confopt . "?", $ethersex_config{$confopt}->{'helptext'}, $d); 
  }
  $ethersex_config{$confopt}->{'value'} = "\"$new_value\"";
}

# check key validity, return 0 if invalid.
sub check_cryptokey {
  my $checkval = shift;
  my $keylen = shift;

  unless (length ($checkval) == $keylen * 2) { return 0; }
  unless ($checkval =~ m/^[0-9a-f]+$/i) { return 0; }
  return 1;
}

sub ask_cryptokey {
  return if($opt_nogui); # defer processing ...

  my $confopt = shift;
  my $keylen = shift;

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  for($default) { s/"//g; s/\\x//g; };
  my $new_value =
    prompt('s', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, 
           sub { 
             my $a = shift; 
             return check_cryptokey ($a, $keylen); 
           } );

  $new_value =~ s/(..)/\\x$1/g;
  $ethersex_config{$confopt}->{'value'} = "\"$new_value\"";
}

sub ask_hex {
  return if($opt_nogui); # defer processing ...

  my $confopt = shift;
  my $hexlen = shift;
  $hexlen = $hexlen * 2;
  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  $default =~ s/0x//;
  my $new_value =
    prompt('e', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, "[A-F0-9]{$hexlen}");

  $new_value =~ s/^/0x/;
  $ethersex_config{$confopt}->{'value'} = "$new_value";
}

sub ask_number {
  return if($opt_nogui); # defer processing ...

  my $confopt = shift;
  my $min = shift;
  my $max = shift;
  my $new_value;

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  if (defined($ethersex_config{$confopt}->{'user_value'})) {
    $new_value = $ethersex_config{$confopt}->{'user_value'};
    goto save_value;
  }

  $default =~ s/0x//;
   $new_value =
    prompt('r', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, $min, $max);
save_value:
  $ethersex_config{$confopt}->{'value'} = "$new_value";
}

sub ask_prefix_len {
  my $confopt = shift;
  ask_number $confopt, 48, 128;
}
#
# check and expand subs for the -D option
#

sub check_and_expand_ip {
  my $checkval = shift;

  my $ipv6;

  if (defined $ethersex_modules{'ipv6'}->{'new_status'}) {
    $ipv6 = $ethersex_modules{'ipv6'}->{'new_status'};
  } else {
    $ipv6 = $ethersex_modules{'ipv6'}->{'enabled'};
  }

  if($ipv6) {
    return check_and_expand_ipv6($checkval);
  }

  return check_and_expand_ipv4($checkval)
}

sub check_and_expand_ipv4 {
  my $checkval = shift;
  # validate ipv4 addr
  my @parts = split m/\./, $checkval;
  if(scalar(@parts) != 4) { return undef; }
  foreach(@parts) {
    if($_ < 0 || $_ > 255) { return undef; }
  }

  return "uip_ipaddr(ip," . join(".", @parts) . ")"; 
}

sub check_and_expand_ipv6 {
  my $checkval = shift;
  if($checkval =~ m/:::/) { return 1; }
  $checkval = ipv6_expand($checkval);
  if (! ($checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){7}$/i)) { return undef; }

  my @parts = split(m/[\.:]/, $checkval);
  return "uip_ip6addr(ip," . join(",", @parts) . ")"; 
}

sub check_and_expand_mac {
  my $checkval = shift;
  if (! $checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){5}$/i) { return undef;}
  for($checkval) {s/:/\\x/g }
  return '"\\x' . $checkval . '"'; 
}

sub check_and_expand_numeric {
  my $checkval = shift;
  return undef if (!($checkval =~ m/^[0-9 ]+$/i));
  return $checkval;
}

sub check_and_expand_string {
  my $checkval = shift;
  return '"' . $checkval . '"';
}

sub check_and_expand_cryptokey {
  my $checkval = shift;
  my $keylen = shift;
  if (!$keylen) { $keylen = 10 };

  if (! check_cryptokey ($a, $keylen)) { return undef };

  $checkval =~ s/(..)/\\x$1/g;

  return  "\"$checkval\"";
}

#
# Enable/disable hooks
#

sub enc28j60_enable_hook {
  ask_mac "etherrape_mac";
}

sub mdns_enable_hook {
  ask_anything "hostname";
}

sub enc28j60_disable_hook {
  # if enc28j60 is disable, only rfm12 or zbus may be enabled ...
  configure_module "rfm12";
  return unless($ethersex_modules{"rfm12"}->{"new_status"});

  configure_module "zbus";
  return unless($ethersex_modules{"zbus"}->{"new_status"});

  disable "zbus", "rfm12";
}

sub tftpomatic_enable_hook {
  # don't ask for tftp image, if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});

  ask_ip("tftp_ip");
  ask_anything("tftp_image");
}

sub tftp_enable_hook {
  # ask for crypto key only if skipjack enabled.
  return unless($ethersex_modules{'skipjack'}->{'new_status'});

  ask_cryptokey("tftp_key", 10);
}

sub ecmd_enable_hook {
  if ($ethersex_modules{'teensy'}->{'new_status'}) {
    enable("udp", "ecmd and teensy");
  } else {
    enable("tcp", "ecmd");
  }
}

sub bootp_enable_hook {
  # ask user for openvpn support (we won't need to enable udp/broadcast then)
  configure_module "openvpn";
  return if($ethersex_modules{'openvpn'}->{'new_status'});
  
  enable "udp", "bootp";
  enable "broadcast", "bootp";
}

sub ipv6_enable_hook {
  # ask user for openvpn support (we won't need a gateway on inner stack otherwise)
  configure_module "openvpn";
  configure_module "ipv6_static";

  ask_ip("etherrape_ip")
    if($ethersex_modules{'openvpn'}->{'new_status'} == 1
       || $ethersex_modules{'enc28j60'}->{'new_status'} == 0
       || $ethersex_modules{'ipv6_static'}->{'new_status'} == 1);

  ask_prefix_len("etherrape_ip6_prefix_len")
    if($ethersex_modules{'ipv6_static'}->{'new_status'} == 1);
}

sub zbus_enable_hook {
  if($ethersex_modules{'enc28j60'}->{'new_status'}) {
    ask_ip("zbus_ip");

    if($ethersex_modules{'ipv6'}->{'new_status'}) {
      ask_prefix_len("zbus_ip6_prefix_len");
    }
    else {
      ask_ip("zbus_ip4_netmask");
    }
  }
  else {  # no enc28j60, i.e. no bridge ...
    disable "rfm12", "zbus";
  }

  return unless($ethersex_modules{'skipjack'}->{'new_status'});
  ask_cryptokey("zbus_key", 10);
}

sub rfm12_enable_hook {
  if($ethersex_modules{'enc28j60'}->{'new_status'}) {
    ask_ip("rfm12_ip");
    
    if($ethersex_modules{'ipv6'}->{'new_status'}) {
      ask_prefix_len("rfm12_ip6_prefix_len");
    }
    else {
      ask_ip("rfm12_ip4_netmask");
    }
  }
  else {  # no enc28j60, i.e. no bridge ...
    disable "zbus", "rfm12";
    $ethersex_config{'rfm12_beacon_id'}->{'value'} = 0;  # force beacon-id undef
  }

  return unless($ethersex_modules{'skipjack'}->{'new_status'});
  ask_cryptokey("rfm12_key", 10);
}

sub rfm12_beacon_enable_hook {
  if($ethersex_modules{'enc28j60'}->{'new_status'}) {
    ask_number "rfm12_beacon_id", 0, 255
  }
  else {
    # force beacon-id undef
    $ethersex_config{'rfm12_beacon_id'}->{'value'} = 0;
  }
}

sub rfm12_cloud_enable_hook {
  ask_anything "rfm12_cloud_dns";
}

sub i2c_slave_enable_hook {
  ask_hex("i2c_slave_addr", 1) if($ethersex_modules{'i2c_slave'}->{'new_status'});
}

sub ipv6_disable_hook {
  # ask user for openvpn support (we won't need a gateway on inner stack otherwise)
  configure_module "openvpn";

  unless ($ethersex_modules{'openvpn'}->{'new_status'}) {
    # ask user for bootp (we won't have to configure IPs otherwise)
    # if openvpn support is disabled.  when openvpn is configured we
    # need to assign static ips on the inner layer no matter what.
    configure_module "bootp";

    # don't ask default ip if user configured bootp
    return if($ethersex_modules{'bootp'}->{'new_status'});
  }
  
  ask_ip("etherrape_ip");
  
  # don't ask for netmask and gateway, if we don't have ethernet support
  configure_module "enc28j60";
  return unless($ethersex_modules{'enc28j60'}->{'new_status'});

  ask_ip("etherrape_ip4_netmask");

  if($ethersex_modules{'openvpn'}->{'new_status'}) {
    print "configuring etherrape_ip4_gateway to 0.0.0.0 (openvpn enabled).\n";
    $ethersex_config{"etherrape_ip4_gateway"}->{'value'} =
      "uip_ipaddr(ip,0,0,0,0)"
  } 
  else {
    ask_ip("etherrape_ip4_gateway");
  }
}

sub openvpn_enable_hook {
  print "** WARNING ** tunneled traffic will not be encrypted!\n\n"
    unless($ethersex_modules{'cast5'}->{'new_status'});
  print "** WARNING ** tunneled traffic will not be authenticated!\n\n"
    unless($ethersex_modules{'md5'}->{'new_status'});

  # ask user for bootp (we won't have to configure IPs otherwise)
  configure_module "bootp";

  # don't ask for ip if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});
  
  unless($ethersex_modules{'ipv6'}->{'new_status'}) {
    ask_ip("openvpn_ip4");
    ask_ip("openvpn_ip4_netmask");
    ask_ip("openvpn_ip4_gateway");
  }

  ask_cryptokey("openvpn_key", 16)
    if($ethersex_modules{'cast5'}->{'new_status'});
  ask_cryptokey("openvpn_hmac_key", 16)
    if($ethersex_modules{'md5'}->{'new_status'});
}

sub dns_enable_hook {
  # don't ask for dns server, if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});

  ask_ip("dns_server");
}

sub dyndns_enable_hook {
  ask_anything("dyndns_hostname");
  ask_anything("dyndns_username");
  ask_anything("dyndns_password");
}

sub syslog_enable_hook {
  ask_ip("syslog_server");
}

sub clock_enable_hook {
  enable("clock_crystal", "clock and teensy") 
    if ($ethersex_modules{'teensy'}->{'new_status'});
}

#
# ask user which modules to enable
#
if ($opt_only_modules != 1) {
  print "\n\n -= ETHERSEX CONFIGURATION =-\n\n";
  configure_module "bootloader";
  configure_module "teensy";
  foreach my $module (keys %ethersex_modules) { configure_module($module) }
}

if ($opt_tk_gui) {
  use Tk;

  sub tk_do_category($) {
    my ($category) = @_;
    my $win = MainWindow->new;  
    my $frame = $win->Frame(-background => 'cyan')->pack;

    foreach my $module (sort @{$categories{$category}->{"modules"}}) { 
      my $widget = $frame->Checkbutton(
        -text => sprintf("%s (%s)", $module, $ethersex_modules{$module}->{"helptext"}),
        -background => 'cyan',
        -variable => \$ethersex_modules{$module}->{"new_status"},
        -command => sub {
	  if($ethersex_modules{$module}->{"new_status"}) {
	    print "enabling $module.\n";
	    enable $module;
	  } else {
	    print "disable $module.\n";
	    disable $module;
	  }
        }
      );
      $widget->pack(-fill => 'x');
      #$widget->select() if($ethersex_modules{$module}->{"new_status"});

      # keep a reference
      $ethersex_modules{$module}->{"widget"} = $widget;
    }
    
    my $button = $win->Button(
      -text	  => "close",
      -command	  => sub { $win->destroy; &tk_make_mainwindow; },
      -background => 'green',
    );
    $button->pack();
  }

  sub tk_make_mainwindow {
    my $mw = MainWindow->new;
    my $frame = $mw->Frame(-background => 'cyan')->pack;

    foreach my $category (sort keys %categories) {
      my $button = $frame->Button(
	-text	    => $categories{$category}->{helptext},
	-command    => sub { $mw->destroy; tk_do_category $category; },
	-background => 'cyan',
      );
      $button->pack(-fill => 'x');
    }

    my $button = $mw->Button(
      -text	  => "exit",
      -command	  => sub { $mw->destroy; },
      -background => 'green',
    );
    $button->pack();
  }

  tk_make_mainwindow; MainLoop;
}

#
# deferred disable/enable hook handling ...
#
if ($opt_nogui) {
  $opt_nogui = 0;   # reset, so callbacks may ask questions ...

  foreach (enable_modules()) {
    if(defined($ethersex_modules{$_}->{'enable_hook'})) {
      $ethersex_modules{$_}->{'enable_hook'}();
    }
  }

  foreach (disable_modules()) {
    if(defined($ethersex_modules{$_}->{'disable_hook'})) {
      $ethersex_modules{$_}->{'disable_hook'}();
    }
  }
}

#
# update config files ...
#
sub write_config {
  my $filename = shift;
  print "writing $filename.\n";

  open INHANDLE, "< $filename"
    or die "unable to open $filename for reading";
  open OUTHANDLE, "> $filename.new"
    or die "unable to open $filename.new for writing";

  while(my $confline = <INHANDLE>) {
    chop $confline;
    my ($enabled, $modname, $line);

    # enable/disable config.h support flag
    if(($enabled, $modname) = $confline =~
       m/^(\/*|\/\/)?\s*#define\s+([A-Z0-9_]+)_SUPPORT\s*(?:\*\/)?\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "// ") . "#define " . $modname . "_SUPPORT";
      }
      # commit config for later module configuration
      $ethersex_modules{lc($modname)}->{'enabled'} =
        $ethersex_modules{lc($modname)}->{'new_status'};
    }

#   # enable/disable Makefile SRC variable editing
#   elsif(($modname) = $confline =~
#      m/^#*\s*SRC\s*\+=\s*\$\(shell echo ([a-z0-9_]+)\/\*\.c\)\s*$/) {
#
#     if(defined($ethersex_modules{lc($modname)})) {
#       $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
#                   ? "" : "#") . "SRC += \$(shell echo $modname/*.c)";
#     }
#   }

    elsif(($modname) = $confline =~
       m/^#*\s*SUBDIRS\s*\+=\s*([a-z0-9_]+)\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "#") . "SUBDIRS += $modname";
      }
    }

    # enable/disable Makefile lines ...
    elsif(($line, $modname) = $confline =~
       m/^#*\s*([^#]+#\s*([A-Z0-9_]+)_SUPPORT)\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "#") . $line;
      }
    }

    # write configuration option
    elsif(($modname) = $confline =~
          m/#define\s+CONF_([A-Z0-9_]+)\s+/) {

      if(defined($ethersex_config{lc($modname)})) {
        $confline = "#define CONF_$modname " 
          . $ethersex_config{lc($modname)}->{'value'};
      }
    }

    print OUTHANDLE "$confline\n";
  }

  close INHANDLE or die;
  close OUTHANDLE or die;

  unlink("$filename") or die;
  rename("$filename.new", "$filename") or die;
}


# make sure config.mk exists
unless (-e "config.mk") { system "make no_deps=t config.mk"; }

#
# write the config files
#
if ($opt_only_modules != 1) {
  foreach(qw/config.h config.mk Makefile/) {
    write_config($_);
  }
}

sub modules_configuration {
  my %configure_modules = ();

  foreach my $module (keys %ethersex_modules) {
    if (-e("$module/configure") and -e("$module/cfgpp")
        and $ethersex_modules{$module}->{'enabled'}) {
      $configure_modules{$module} = $ethersex_modules{$module};
    }
  }
  return unless scalar(keys %configure_modules);

  my $choice;
  do {
    print "\n== configure ethersex modules ==\n\n";
    my $x = 1;
    foreach my $t (keys(%configure_modules)) {
      print "$x. $t - " . $configure_modules{$t}->{'helptext'} . "\n";
      $x++;
    }
    print "\n0. Exit\n";

    $choice = prompt('n', 'Please Choose:', '', '0');
    if($choice > scalar(keys %configure_modules)) {
      print "invalid choice, try again.\n\n";
      next;
    }

    if($choice) {
      system((keys(%configure_modules))[$choice - 1] . "/configure");
    }

  } while ($choice);
}

#
# configure the selected modules
#

modules_configuration

print "\n\nsuccessfully configured your ethersex.\n\n";
