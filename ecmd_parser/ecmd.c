/* vim:fdm=marker ts=4 et ai
 * {{{
 *
 * Copyright (c) by Alexander Neumann <alexander@bumpern.de>
 * Copyright (c) 2007,2008 by Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2007,2008 by Christian Dietrich <stettberger@dokucode.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * For more information on the GPL, please go to:
 * http://www.gnu.org/copyleft/gpl.html
 }}} */

#include <string.h>
#include <avr/pgmspace.h>
#include <avr/eeprom.h>
#include <avr/interrupt.h>

#include "../config.h"
#include "../debug.h"
#include "../uip/uip.h"
#include "../uip/uip_arp.h"
#include "../eeprom.h"
#include "../bit-macros.h"
#include "../fs20/fs20.h"
#include "../portio.h"
#include "../lcd/hd44780.h"
#include "../named_pin/named_pin.h"
#include "../onewire/onewire.h"
#include "../rc5/rc5.h"
#include "../rfm12/rfm12.h"
#include "../rfm12/rfm12_ask.h"
#include "../dns/resolv.h"
#include "../clock/clock.h"
#include "../yport/yport.h"
#include "../control6/control6.h"
#include "../syslog/syslog.h"
#include "ecmd.h"

#define xstr(s) str(s)
#define str(s) #s

/* struct for storing commands */
struct ecmd_command_t {
    PGM_P name;
    int16_t (*func)(char*, char*, uint16_t);
};

/* Include the function header, generated by m4 */
#include "ecmd_defs.c"

int16_t ecmd_parse_command(char *cmd, char *output, uint16_t len)
/* {{{ */ {

#ifdef DEBUG_ECMD
    debug_printf("called ecmd_parse_command %s\n", cmd);
#endif

    if (strlen(cmd) <= 2) {
#ifdef DEBUG_ECMD
        debug_printf("cmd is too short\n");
#endif
        return 0;
    }

    int ret = -1;

    char *text = NULL;
    int16_t (*func)(char*, char*, uint16_t) = NULL;
    uint8_t pos = 0;

    while (1) {
        /* load pointer to text */
        text = (char *)pgm_read_word(&ecmd_cmds[pos].name);

#ifdef DEBUG_ECMD
        debug_printf("loaded text addres %p: \n", text);
#endif

        /* return if we reached the end of the array */
        if (text == NULL)
            break;

#ifdef DEBUG_ECMD
        debug_printf("text is: \"%S\"\n", text);
#endif

        /* else compare texts */
        if (memcmp_P(cmd, text, strlen_P(text)) == 0) {
#ifdef DEBUG_ECMD
            debug_printf("found match\n");
#endif
            cmd += strlen_P(text);
            func = (void *)pgm_read_word(&ecmd_cmds[pos].func);
            break;
        }

        pos++;
    }

#ifdef DEBUG_ECMD
    debug_printf("rest cmd: \"%s\"\n", cmd);
#endif

    if (func != NULL)
        ret = func(cmd, output, len);

    if (ret == -1 && output != NULL) {
        memcpy_P(output, PSTR("parse error"), 11);
        ret = 11;
    } else if (ret == 0) {
        output[0] = 'O';
        output[1] = 'K';
        ret = 2;
    }

    return ret;
} /* }}} */

int16_t parse_cmd_bootloader(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    (void) cmd;
    (void) output;
    (void) len;

    status.request_bootloader = 1;
#   ifdef UIP_SUPPORT
    uip_close();
#   endif
    return 0;
} /* }}} */

#ifdef FREE_SUPPORT

int16_t parse_cmd_free(char *cmd, char *output, uint16_t len)
{
  extern char *__brkval;
  debug_printf("free: %d %d %d\n", RAMEND, RAMEND - SP, SP - (uint16_t) __brkval);
  return snprintf_P(output, len, 
                    PSTR("%d free; %d malloc; buffer " xstr(NET_MAX_FRAME_LENGTH)),
                    /* __brkval is 0 when malloc was not called yet */
                    SP - (uint16_t) (__brkval ? __brkval : __malloc_heap_start),
                    (uint16_t) (__brkval ? (__brkval - __malloc_heap_start) : 0));
 
}

#endif /* FREE_SUPPORT */

#ifndef TEENSY_SUPPORT
int16_t parse_cmd_show_version(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    (void) cmd;

    return snprintf_P(output, len,
            PSTR("version %s"), VERSION_STRING);
} /* }}} */

int16_t parse_cmd_reset(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    (void) cmd;
    (void) output;
    (void) len;

    status.request_reset = 1;
#ifdef UIP_SUPPORT
    uip_close();
#endif
    return 0;
} /* }}} */

int16_t parse_cmd_wdreset(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    status.request_wdreset = 1;
#ifdef UIP_SUPPORT
    uip_close();
#endif
    return 0;
} /* }}} */

int16_t parse_cmd_d(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    (void) len;

    while (*cmd == ' ') cmd ++;

    uint16_t temp;
    if (sscanf_P (cmd, PSTR("%x"), &temp) != 1)
      return -1;

    unsigned char *ptr = (void *) temp;
    for (int i = 0; i < 16; i ++)
      sprintf_P (output + (i << 1), PSTR("%02x"), * (ptr ++));

    return 32;
} /* }}} */

int16_t parse_cmd_help(char *cmd, char *output, uint16_t len)
{
    (void) len;

    if (cmd[0] != 23) {
	cmd[0] = 23;
	cmd[1] = 0;
    }

    char *text = (char *)pgm_read_word(&ecmd_cmds[(uint8_t) cmd[1] ++].name);
    len = strlen_P (text);
    memcpy_P (output, text, len);

    text = (char *) pgm_read_word(&ecmd_cmds[(uint8_t) cmd[1]].name);
    return text ? (-10 - len) : len;
}

#endif /* TEENSY_SUPPORT */

#ifdef EEPROM_SUPPORT
int16_t parse_cmd_eeprom_reinit(char *cmd, char *output, uint16_t len)
{
    (void) cmd;
    (void) output;
    (void) len;

    eeprom_init ();
    return 0;
}
#endif  /* EEPROM_SUPPORT */


