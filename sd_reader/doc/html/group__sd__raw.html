<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>sd-reader: MMC/SD/SDHC card raw access</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MMC/SD/SDHC card raw access</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This module implements read and write access to MMC, SD and SDHC cards. 
<p>
It serves as a low-level driver for the higher level modules such as partition and file system access. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd__raw_8c.html">sd_raw.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MMC/SD/SDHC raw access implementation (license: GPLv2 or LGPLv2.1). <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd__raw_8h.html">sd_raw.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MMC/SD/SDHC raw access header (license: GPLv2 or LGPLv2.1). <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd__raw__config_8h.html">sd_raw_config.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MMC/SD support configuration (license: GPLv2 or LGPLv2.1). <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw__config.html">MMC/SD configuration</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preprocessor defines to configure the MMC/SD support. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsd__raw__info.html">sd_raw_info</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This struct is used by <a class="el" href="group__sd__raw.html#g97c54e82834f87bcdd38e79822fe5a79" title="Reads informational data from the card.">sd_raw_get_info()</a> to return manufacturing and status information of the card.  <a href="structsd__raw__info.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2507a78d61385c9dbc1d06b8a03ef58a"></a><!-- doxytag: member="sd_raw::SD_RAW_FORMAT_HARDDISK" ref="g2507a78d61385c9dbc1d06b8a03ef58a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g2507a78d61385c9dbc1d06b8a03ef58a">SD_RAW_FORMAT_HARDDISK</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The card's layout is harddisk-like, which means it contains a master boot record with a partition table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4caede5500f4d1035ceb9951a831c224"></a><!-- doxytag: member="sd_raw::SD_RAW_FORMAT_SUPERFLOPPY" ref="g4caede5500f4d1035ceb9951a831c224" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g4caede5500f4d1035ceb9951a831c224">SD_RAW_FORMAT_SUPERFLOPPY</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The card contains a single filesystem and no partition table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd070d05f762410f57870549a0fcd5f43"></a><!-- doxytag: member="sd_raw::SD_RAW_FORMAT_UNIVERSAL" ref="gd070d05f762410f57870549a0fcd5f43" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#gd070d05f762410f57870549a0fcd5f43">SD_RAW_FORMAT_UNIVERSAL</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The card's layout follows the Universal File Format. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7e87231437f32335a25930ec1b85a9c9"></a><!-- doxytag: member="sd_raw::SD_RAW_FORMAT_UNKNOWN" ref="g7e87231437f32335a25930ec1b85a9c9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g7e87231437f32335a25930ec1b85a9c9">SD_RAW_FORMAT_UNKNOWN</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The card's layout is unknown. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g82e8599b2679451e491484fb0b19bfd5">sd_raw_init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes memory card communication.  <a href="#g82e8599b2679451e491484fb0b19bfd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g5e227f25ad4a18466e7cdd9ecdfce8ab">sd_raw_available</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether a memory card is located in the slot.  <a href="#g5e227f25ad4a18466e7cdd9ecdfce8ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g55f311428473cd5b85cf8f24ffba121b">sd_raw_locked</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the memory card is locked for write access.  <a href="#g55f311428473cd5b85cf8f24ffba121b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g3da1870e406622511379a66370cdc774">sd_raw_read</a> (offset_t offset, uint8_t *buffer, uintptr_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads raw data from the card.  <a href="#g3da1870e406622511379a66370cdc774"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#gf7eb53b23a8a91aaae785379da1527c9">sd_raw_read_interval</a> (offset_t offset, uint8_t *buffer, uintptr_t interval, uintptr_t length, sd_raw_read_interval_handler_t callback, void *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continuously reads units of <code>interval</code> bytes and calls a callback function.  <a href="#gf7eb53b23a8a91aaae785379da1527c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g0e46673759c1aa9ba492c8d123a3c577">sd_raw_write</a> (offset_t offset, const uint8_t *buffer, uintptr_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes raw data to the card.  <a href="#g0e46673759c1aa9ba492c8d123a3c577"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g7c60c1314055991e0812b659fe4e6c68">sd_raw_write_interval</a> (offset_t offset, uint8_t *buffer, uintptr_t length, sd_raw_write_interval_handler_t callback, void *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a continuous data stream obtained from a callback function.  <a href="#g7c60c1314055991e0812b659fe4e6c68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#gd4d9ff40a7ea50c65cfa47927b35b735">sd_raw_sync</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the write buffer's content to the card.  <a href="#gd4d9ff40a7ea50c65cfa47927b35b735"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sd__raw.html#g97c54e82834f87bcdd38e79822fe5a79">sd_raw_get_info</a> (struct <a class="el" href="structsd__raw__info.html">sd_raw_info</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads informational data from the card.  <a href="#g97c54e82834f87bcdd38e79822fe5a79"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g5e227f25ad4a18466e7cdd9ecdfce8ab"></a><!-- doxytag: member="sd_raw.c::sd_raw_available" ref="g5e227f25ad4a18466e7cdd9ecdfce8ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_available           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks wether a memory card is located in the slot. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the card is available, 0 if it is not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g97c54e82834f87bcdd38e79822fe5a79"></a><!-- doxytag: member="sd_raw.c::sd_raw_get_info" ref="g97c54e82834f87bcdd38e79822fe5a79" args="(struct sd_raw_info *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_get_info           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsd__raw__info.html">sd_raw_info</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads informational data from the card. 
<p>
This function reads and returns the card's registers containing manufacturing and status information.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>: The information retrieved by this function is not required in any way to operate on the card, but it might be nice to display some of the data to the user.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>A pointer to the structure into which to save the information. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g82e8599b2679451e491484fb0b19bfd5"></a><!-- doxytag: member="sd_raw.c::sd_raw_init" ref="g82e8599b2679451e491484fb0b19bfd5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes memory card communication. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g55f311428473cd5b85cf8f24ffba121b"></a><!-- doxytag: member="sd_raw.c::sd_raw_locked" ref="g55f311428473cd5b85cf8f24ffba121b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_locked           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks wether the memory card is locked for write access. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the card is locked, 0 if it is not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3da1870e406622511379a66370cdc774"></a><!-- doxytag: member="sd_raw.c::sd_raw_read" ref="g3da1870e406622511379a66370cdc774" args="(offset_t offset, uint8_t *buffer, uintptr_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_read           </td>
          <td>(</td>
          <td class="paramtype">offset_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads raw data from the card. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset from which to read. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer into which to write the data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to read. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__sd__raw.html#gf7eb53b23a8a91aaae785379da1527c9" title="Continuously reads units of interval bytes and calls a callback function.">sd_raw_read_interval</a>, <a class="el" href="group__sd__raw.html#g0e46673759c1aa9ba492c8d123a3c577" title="Writes raw data to the card.">sd_raw_write</a>, <a class="el" href="group__sd__raw.html#g7c60c1314055991e0812b659fe4e6c68" title="Writes a continuous data stream obtained from a callback function.">sd_raw_write_interval</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf7eb53b23a8a91aaae785379da1527c9"></a><!-- doxytag: member="sd_raw.c::sd_raw_read_interval" ref="gf7eb53b23a8a91aaae785379da1527c9" args="(offset_t offset, uint8_t *buffer, uintptr_t interval, uintptr_t length, sd_raw_read_interval_handler_t callback, void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_read_interval           </td>
          <td>(</td>
          <td class="paramtype">offset_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sd_raw_read_interval_handler_t&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Continuously reads units of <code>interval</code> bytes and calls a callback function. 
<p>
This function starts reading at the specified offset. Every <code>interval</code> bytes, it calls the callback function with the associated data buffer.<p>
By returning zero, the callback may stop reading.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Within the callback function, you can not start another read or write operation. <p>
This function only works if the following conditions are met:<ul>
<li>(offset - (offset % 512)) % interval == 0</li><li>length % interval == 0</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset from which to start reading. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to a buffer which is at least interval bytes in size. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interval</em>&nbsp;</td><td>Number of bytes to read before calling the callback function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Number of bytes to read altogether. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>The function to call every interval bytes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>An opaque pointer directly passed to the callback function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__sd__raw.html#g7c60c1314055991e0812b659fe4e6c68" title="Writes a continuous data stream obtained from a callback function.">sd_raw_write_interval</a>, <a class="el" href="group__sd__raw.html#g3da1870e406622511379a66370cdc774" title="Reads raw data from the card.">sd_raw_read</a>, <a class="el" href="group__sd__raw.html#g0e46673759c1aa9ba492c8d123a3c577" title="Writes raw data to the card.">sd_raw_write</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd4d9ff40a7ea50c65cfa47927b35b735"></a><!-- doxytag: member="sd_raw.c::sd_raw_sync" ref="gd4d9ff40a7ea50c65cfa47927b35b735" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_sync           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the write buffer's content to the card. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When write buffering is enabled, you should call this function before disconnecting the card to ensure all remaining data has been written.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__sd__raw.html#g0e46673759c1aa9ba492c8d123a3c577" title="Writes raw data to the card.">sd_raw_write</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0e46673759c1aa9ba492c8d123a3c577"></a><!-- doxytag: member="sd_raw.c::sd_raw_write" ref="g0e46673759c1aa9ba492c8d123a3c577" args="(offset_t offset, const uint8_t *buffer, uintptr_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_write           </td>
          <td>(</td>
          <td class="paramtype">offset_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes raw data to the card. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If write buffering is enabled, you might have to call <a class="el" href="group__sd__raw.html#gd4d9ff40a7ea50c65cfa47927b35b735" title="Writes the write buffer&#39;s content to the card.">sd_raw_sync()</a> before disconnecting the card to ensure all remaining data has been written.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset where to start writing. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer containing the data to be written. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to write. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__sd__raw.html#g7c60c1314055991e0812b659fe4e6c68" title="Writes a continuous data stream obtained from a callback function.">sd_raw_write_interval</a>, <a class="el" href="group__sd__raw.html#g3da1870e406622511379a66370cdc774" title="Reads raw data from the card.">sd_raw_read</a>, <a class="el" href="group__sd__raw.html#gf7eb53b23a8a91aaae785379da1527c9" title="Continuously reads units of interval bytes and calls a callback function.">sd_raw_read_interval</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7c60c1314055991e0812b659fe4e6c68"></a><!-- doxytag: member="sd_raw.c::sd_raw_write_interval" ref="g7c60c1314055991e0812b659fe4e6c68" args="(offset_t offset, uint8_t *buffer, uintptr_t length, sd_raw_write_interval_handler_t callback, void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sd_raw_write_interval           </td>
          <td>(</td>
          <td class="paramtype">offset_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sd_raw_write_interval_handler_t&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a continuous data stream obtained from a callback function. 
<p>
This function starts writing at the specified offset. To obtain the next bytes to write, it calls the callback function. The callback fills the provided data buffer and returns the number of bytes it has put into the buffer.<p>
By returning zero, the callback may stop writing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset where to start writing. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to a buffer which is used for the callback function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Number of bytes to write in total. May be zero for endless writes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>The function used to obtain the bytes to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>An opaque pointer directly passed to the callback function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__sd__raw.html#gf7eb53b23a8a91aaae785379da1527c9" title="Continuously reads units of interval bytes and calls a callback function.">sd_raw_read_interval</a>, <a class="el" href="group__sd__raw.html#g0e46673759c1aa9ba492c8d123a3c577" title="Writes raw data to the card.">sd_raw_write</a>, <a class="el" href="group__sd__raw.html#g3da1870e406622511379a66370cdc774" title="Reads raw data from the card.">sd_raw_read</a> </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Nov 21 09:17:15 2008 for sd-reader by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
