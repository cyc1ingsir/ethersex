/* This file has been generated by m4 system automatically.
   Please do not modify it, edit the m4 scripts below ipchair/ instead. */

#ifdef IPCHAIR_HEADER
#ifndef __IPCHAIR_HDR
#define __IPCHAIR_HDR

#include "../uip/uip.h"

typedef void builtin_return_t;
typedef uint8_t user_return_t;



;
;





#define IPCHAIR_HAVE_MASQUERADE
user_return_t ipchair_MASQUERADE_chair(void);

#define IPCHAIR_HAVE_MAYBE_DEMASQUERADE
user_return_t ipchair_MAYBE_DEMASQUERADE_chair(void);

#define IPCHAIR_HAVE_MAYBE_DEMASQUERADE_TCP
user_return_t ipchair_MAYBE_DEMASQUERADE_TCP_chair(void);

#define IPCHAIR_HAVE_MAYBE_DEMASQUERADE_UDP
user_return_t ipchair_MAYBE_DEMASQUERADE_UDP_chair(void);

#define IPCHAIR_HAVE_DEMASQUERADE
user_return_t ipchair_DEMASQUERADE_chair(void);

#define IPCHAIR_HAVE_INPUT
builtin_return_t ipchair_INPUT_chair(void);


#endif /* __IPCHAIR_HDR */
#else
#include "ipchair.h"

#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define BUF_TCP ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define BUF_UDP ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define BUF_ICMP ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define BUF_ICMP6 ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])

/* Structures and definitions. */
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20
#define TCP_CTL 0x3f

#define TCP_OPT_END     0   /* End of TCP options list */
#define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
#define TCP_OPT_MSS     2   /* Maximum segment size TCP option */

#define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */

#define ICMP_ECHO_REPLY 0
#define ICMP_ECHO       8

#define ICMP6_ECHO_REPLY             129
#define ICMP6_ECHO                   128
#define ICMP6_ROUTER_SOLICITATION    133
#define ICMP6_ROUTER_ADVERTISEMENT   134
#define ICMP6_NEIGHBOR_SOLICITATION  135
#define ICMP6_NEIGHBOR_ADVERTISEMENT 136

#define ICMP6_FLAG_S (1 << 6)

#define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
#define ICMP6_OPTION_TARGET_LINK_ADDRESS 2

#ifndef IPCHAIR_NEED_MAYBE_DEMASQUERADE_TCP
#define IPCHAIR_NEED_MAYBE_DEMASQUERADE_TCP 1
#endif
#ifndef IPCHAIR_NEED_MAYBE_DEMASQUERADE_UDP
#define IPCHAIR_NEED_MAYBE_DEMASQUERADE_UDP 1
#endif
#ifndef IPCHAIR_NEED_DEMASQUERADE
#define IPCHAIR_NEED_DEMASQUERADE 1
#endif
#ifndef IPCHAIR_NEED_DEMASQUERADE
#define IPCHAIR_NEED_DEMASQUERADE 1
#endif
#ifndef IPCHAIR_NEED_DEMASQUERADE
#define IPCHAIR_NEED_DEMASQUERADE 1
#endif
#ifndef IPCHAIR_NEED_DEMASQUERADE
#define IPCHAIR_NEED_DEMASQUERADE 1
#endif
static uip_ipaddr_t ipchair_masq_peer_addr;

user_return_t
ipchair_MASQUERADE_chair(void)
{
  if (uip_stack_get_active() != STACK_USB)
     {
    return 1;
  }

    uip_ipaddr_copy(ipchair_masq_peer_addr, BUF->srcipaddr);

    uip_ipaddr_copy(BUF->srcipaddr, enc_stack_hostaddr);
  #ifndef IPV6_SUPPORT
  BUF->ipchksum = 0;
  BUF->ipchksum = ~(uip_ipchksum());
#endif


  
  if(1)  {
    return 0;
  }
  /* call failed, continue in parent */ return 1;
}



user_return_t
ipchair_MAYBE_DEMASQUERADE_chair(void)
{
  if (! uip_ipaddr_cmp(BUF->destipaddr, enc_stack_hostaddr))
     {
    return 1;
  }  
  if (BUF->proto == UIP_PROTO_TCP && 1) { 
    if(ipchair_MAYBE_DEMASQUERADE_TCP_chair() == 0)
      return 0;
  }
  if (BUF->proto == UIP_PROTO_UDP && 1) { 
    if(ipchair_MAYBE_DEMASQUERADE_UDP_chair() == 0)
      return 0;
  }

#ifdef IPV6_SUPPORT
  if (BUF->proto == UIP_PROTO_ICMP6 && BUF_ICMP6->type == ICMP6_ECHO_REPLY && 1) { 
    if(ipchair_DEMASQUERADE_chair() == 0)
      return 0;
  }
#else
  if (BUF->proto == UIP_PROTO_ICMP && BUF_ICMP->type == ICMP_ECHO_REPLY && 1) { 
    if(ipchair_DEMASQUERADE_chair() == 0)
      return 0;
  }
#endif

  
  if(1)  {
    return 1;
  }
  /* call failed, continue in parent */ return 1;
}



user_return_t
ipchair_MAYBE_DEMASQUERADE_TCP_chair(void)
{
  register uip_conn_t *uip_connr = uip_conn;
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
       BUF->destport == uip_connr->lport &&
       BUF->srcport == uip_connr->rport &&
       uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
       {
    return 1;
  }      }
  }
  

  uint8_t c;
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(BUF->destport == uip_listenports[c].port)
       {
    return 1;
  }    }

  
  if(1) { 
    if(ipchair_DEMASQUERADE_chair() == 0)
      return 0;
  }
  /* call failed, continue in parent */ return 1;
}



user_return_t
ipchair_MAYBE_DEMASQUERADE_UDP_chair(void)
{
  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[UIP_UDP_CONNS - 1];
      uip_udp_conn >= &uip_udp_conns[0];
      --uip_udp_conn) {
    /* If the local UDP port is non-zero, the connection is considered
       to be used. If so, the local port number is checked against the
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       BUF_UDP->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        BUF_UDP->srcport == uip_udp_conn->rport) &&
       uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr)) {
       {
    return 1;
  }      }
  }

  
  if(1) { 
    if(ipchair_DEMASQUERADE_chair() == 0)
      return 0;
  }
  /* call failed, continue in parent */ return 1;
}



user_return_t
ipchair_DEMASQUERADE_chair(void)
{
  uip_ipaddr_copy(BUF->destipaddr, ipchair_masq_peer_addr);
  #ifndef IPV6_SUPPORT
  BUF->ipchksum = 0;
  BUF->ipchksum = ~(uip_ipchksum());
#endif


  
  if(1)  {
    return 0;
  }
  /* call failed, continue in parent */ return 1;
}


builtin_return_t
ipchair_INPUT_chair(void)
{

#ifdef OPENVPN_SUPPORT
  if (uip_stack_get_active() == STACK_OPENVPN && 1)  {
    return ;
  }
  if (BUF->proto == UIP_PROTO_TCP && BUF_TCP->destport == HTONS(2701) && 1)  {
    uip_len = 0;
    return ;
  }
#endif


  policy:
  if(1)  {
    return ;
  }
  
}
#endif
